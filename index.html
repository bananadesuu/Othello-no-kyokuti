<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>AIå¯¾æˆ¦ã‚ªã‚»ãƒ­ (é™ç•Œçªç ´ç‰ˆ)</title>
    <style>
        /* ... (CSSã‚¹ã‚¿ã‚¤ãƒ«ã¯å¤‰æ›´ãªã—) ... */
        /* åŸºæœ¬è¨­å®š */
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            background-color: #f0f0f0;
        }

        h1 {
            color: #333;
        }

        #message {
            font-size: 1.2em;
            margin: 10px 0;
            font-weight: bold;
        }

        /* ã‚ªã‚»ãƒ­ç›¤ã®è¨­å®š */
        #board-container {
            display: grid;
            grid-template-columns: repeat(8, 60px); 
            grid-template-rows: repeat(8, 60px);    
            width: 480px; 
            height: 480px;
            border: 3px solid #333;
            margin: 20px auto; 
            box-shadow: 5px 5px 10px rgba(0, 0, 0, 0.5);
        }

        /* ãƒã‚¹ã®ã‚¹ã‚¿ã‚¤ãƒ« */
        .cell {
            width: 60px;
            height: 60px;
            background-color: #008000;
            border: 1px solid #000;
            display: flex;
            justify-content: center; 
            align-items: center;
            cursor: pointer;
            position: relative;
        }

        /* çŸ³ã®å…±é€šã‚¹ã‚¿ã‚¤ãƒ« */
        .disc {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            transition: background-color 0.3s ease; 
        }

        /* é»’ã„çŸ³ */
        .disc.black {
            background-color: black;
        }

        /* ç™½ã„çŸ³ */
        .disc.white {
            background-color: white;
        }

        /* ç½®ã‘ã‚‹ãƒã‚¹ã«ãƒ’ãƒ³ãƒˆã‚’è¡¨ç¤º */
        .cell.hint::after {
            content: '';
            display: block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.6);
            position: absolute;
        }
    </style>
</head>
<body>
    <h1>AIå¯¾æˆ¦ã‚ªã‚»ãƒ­ (é™ç•Œçªç ´ç‰ˆ)</h1>
    
    <div id="message">ã‚²ãƒ¼ãƒ é–‹å§‹ï¼ã‚ãªãŸã®ç•ªã§ã™ (é»’)</div>

    <div id="board-container"></div>
    
    <button id="reset-button">ã‚²ãƒ¼ãƒ ãƒªã‚»ãƒƒãƒˆ</button>

    <script>
        // --- å®šæ•°ã¨å¤‰æ•° ---
        const EMPTY = 0;
        const BLACK = 1; // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼
        const WHITE = 2; // AI

        // ã€æœ€å¼·ã®æ ¸ 1ã€‘ä½ç½®è©•ä¾¡ãƒ†ãƒ¼ãƒ–ãƒ«
        const POSITION_WEIGHTS = [
            [ 100, -20,  10,  5,  5,  10, -20,  100], 
            [-20, -50,  -2, -2, -2,  -2, -50,  -20], 
            [ 10,  -2,  -1, -1, -1,  -1,  -2,   10],
            [  5,  -2,  -1,  0,  0,  -1,  -2,    5],
            [  5,  -2,  -1,  0,  0,  -1,  -2,    5],
            [ 10,  -2,  -1, -1, -1,  -1,  -2,   10],
            [-20, -50,  -2, -2, -2,  -2, -50,  -20],
            [ 100, -20,  10,  5,  5,  10, -20,  100]
        ];
        
        // ã€é™ç•Œçªç ´å¼·åŒ–ã€‘
        const MIDGAME_SEARCH_DEPTH = 6; // ä¸­ç›¤æˆ¦ã®æ¢ç´¢æ·±ã•ã‚’ 6 ã«å¼·åŒ–
        const ENDGAME_THRESHOLD = 15;   // ç©ºããƒã‚¹ãŒ15ä»¥ä¸‹ã«ãªã£ãŸã‚‰å…¨æ¢ç´¢é–‹å§‹ã«å¼·åŒ–
        const MOBILITY_WEIGHT = 5;      
        
        let board; 
        let currentPlayer;
        let isGameOver = false;
        const boardContainer = document.getElementById('board-container');
        const messageElement = document.getElementById('message');
        const resetButton = document.getElementById('reset-button');

        const DIRECTIONS = [
            [-1, 0], [1, 0], [0, -1], [0, 1], 
            [-1, -1], [-1, 1], [1, -1], [1, 1]
        ];

        // --- åŸºæœ¬é–¢æ•°ï¼ˆå¤‰æ›´ãªã—ï¼‰ ---

        function updateMessage(text) {
            messageElement.textContent = text;
        }

        function initGame() {
            board = [
                [0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, WHITE, BLACK, 0, 0, 0],
                [0, 0, 0, BLACK, WHITE, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0]
            ];
            currentPlayer = BLACK;
            isGameOver = false;
            drawBoard();
            updateMessage("ã‚²ãƒ¼ãƒ é–‹å§‹ï¼ã‚ãªãŸã®ç•ªã§ã™ (é»’)");
        }
        
        function getFlips(currentBoard, r, c, player) {
            if (currentBoard[r][c] !== EMPTY) return []; 
            const opponent = player === BLACK ? WHITE : BLACK;
            let flippedDiscs = [];
            for (const [dr, dc] of DIRECTIONS) {
                let currentFlips = [];
                let nr = r + dr;
                let nc = c + dc;
                while (nr >= 0 && nr < 8 && nc >= 0 && nc < 8 && currentBoard[nr][nc] === opponent) {
                    currentFlips.push({ row: nr, col: nc });
                    nr += dr;
                    nc += dc;
                }
                if (nr >= 0 && nr < 8 && nc >= 0 && nc < 8 && currentBoard[nr][nc] === player) {
                    flippedDiscs.push(...currentFlips);
                }
            }
            return flippedDiscs;
        }

        function isValidMove(currentBoard, r, c, player) {
            return getFlips(currentBoard, r, c, player).length > 0;
        }

        function makeMove(currentBoard, r, c, player) {
            const flips = getFlips(currentBoard, r, c, player);
            currentBoard[r][c] = player;
            for (const { row, col } of flips) {
                currentBoard[row][col] = player;
            }
        }

        function getValidMoves(currentBoard, player) {
            const moves = [];
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (currentBoard[r][c] === EMPTY && isValidMove(currentBoard, r, c, player)) {
                        moves.push({ row: r, col: c });
                    }
                }
            }
            return moves;
        }

        // --- AIãƒ­ã‚¸ãƒƒã‚¯ï¼ˆãƒŸãƒ‹ãƒãƒƒã‚¯ã‚¹/è©•ä¾¡é–¢æ•°ï¼‰ ---
        
        function checkGameOverState(currentBoard) {
            const blackMoves = getValidMoves(currentBoard, BLACK).length;
            const whiteMoves = getValidMoves(currentBoard, WHITE).length;
            return blackMoves === 0 && whiteMoves === 0;
        }

        function finalScoreEvaluation(currentBoard) {
            let whiteCount = 0;
            let blackCount = 0;
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (currentBoard[r][c] === WHITE) whiteCount++;
                    if (currentBoard[r][c] === BLACK) blackCount++;
                }
            }
            // è©•ä¾¡å€¤ã®ã‚¹ã‚±ãƒ¼ãƒ«ã‚’åˆã‚ã›ã‚‹ãŸã‚ã«å¤§ããªä¿‚æ•°ã‚’ã‹ã‘ã‚‹
            return (whiteCount - blackCount) * 100000; 
        }

        function midgameEvaluation(currentBoard) {
            let whiteScore = 0;
            let blackScore = 0;

            // 1. ä½ç½®è©•ä¾¡ (Placement Score)
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const weight = POSITION_WEIGHTS[r][c];
                    if (currentBoard[r][c] === WHITE) {
                        whiteScore += weight;
                    } else if (currentBoard[r][c] === BLACK) {
                        blackScore += weight;
                    }
                }
            }

            // 2. ãƒ¢ãƒ“ãƒªãƒ†ã‚£è©•ä¾¡ (Mobility Score)
            const whiteMobility = getValidMoves(currentBoard, WHITE).length;
            const blackMobility = getValidMoves(currentBoard, BLACK).length;
            const mobilityScore = MOBILITY_WEIGHT * (whiteMobility - blackMobility);

            // æœ€çµ‚ã‚¹ã‚³ã‚¢: (ä½ç½®è©•ä¾¡ã®å·®) + (ãƒ¢ãƒ“ãƒªãƒ†ã‚£è©•ä¾¡)
            return (whiteScore - blackScore) + mobilityScore;
        }
        
        function countEmptyCells(currentBoard) {
            let emptyCount = 0;
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (currentBoard[r][c] === EMPTY) emptyCount++;
                }
            }
            return emptyCount;
        }


        // ã‚¢ãƒ«ãƒ•ã‚¡ãƒ™ãƒ¼ã‚¿æåˆˆã‚Šä»˜ããƒŸãƒ‹ãƒãƒƒã‚¯ã‚¹æ³•
        function minimax(currentBoard, depth, alpha, beta, isMaximizingPlayer) {
            const emptyCells = countEmptyCells(currentBoard);
            const isEndgame = emptyCells <= ENDGAME_THRESHOLD;

            // æ¢ç´¢çµ‚äº†æ¡ä»¶
            if (depth === 0 || checkGameOverState(currentBoard) || isEndgame) {
                // çµ‚ç›¤ã«çªå…¥ã—ãŸã‚‰ã€æœ€çµ‚çš„ãªçŸ³æ•°ã§è©•ä¾¡
                if (checkGameOverState(currentBoard) || isEndgame) {
                     return finalScoreEvaluation(currentBoard);
                }
                // ä¸­ç›¤ã®æ¢ç´¢æ·±ã•é™ç•Œã«é”ã—ãŸã‚‰ã€ä¸­ç›¤è©•ä¾¡é–¢æ•°ã§è©•ä¾¡
                return midgameEvaluation(currentBoard);
            }

            const player = isMaximizingPlayer ? WHITE : BLACK;
            const validMoves = getValidMoves(currentBoard, player);
            
            // ãƒ‘ã‚¹ã®å‡¦ç†
            if (validMoves.length === 0) {
                return minimax(currentBoard, depth - 1, alpha, beta, !isMaximizingPlayer);
            }

            if (isMaximizingPlayer) {
                let maxEval = -Infinity;
                for (const move of validMoves) {
                    const newBoard = currentBoard.map(row => [...row]); 
                    makeMove(newBoard, move.row, move.col, player);
                    const evaluation = minimax(newBoard, depth - 1, alpha, beta, false);
                    maxEval = Math.max(maxEval, evaluation);
                    alpha = Math.max(alpha, maxEval);
                    if (beta <= alpha) break; 
                }
                return maxEval;
            } else {
                let minEval = Infinity;
                for (const move of validMoves) {
                    const newBoard = currentBoard.map(row => [...row]);
                    makeMove(newBoard, move.row, move.col, player);
                    const evaluation = minimax(newBoard, depth - 1, alpha, beta, true);
                    minEval = Math.min(minEval, evaluation);
                    beta = Math.min(beta, minEval);
                    if (beta <= alpha) break; 
                }
                return minEval;
            }
        }

        // AIã®æœ€å–„æ‰‹ã‚’æ±ºå®šã™ã‚‹ãƒ¡ã‚¤ãƒ³é–¢æ•°
        function findAIBestMove(currentBoard) {
            const validMoves = getValidMoves(currentBoard, WHITE);
            if (validMoves.length === 0) return null;

            const emptyCells = countEmptyCells(currentBoard);
            
            // çµ‚ç›¤æˆ¦ã®åˆ¤å®šã¨æ·±åº¦è¨­å®š
            const isEndgame = emptyCells <= ENDGAME_THRESHOLD;
            const depth = isEndgame ? emptyCells : MIDGAME_SEARCH_DEPTH;

            if(isEndgame) {
                updateMessage(`AI (ç™½) ã®æ€è€ƒä¸­ã§ã™...ã€çµ‚ç›¤ãƒ‘ãƒ¼ãƒ•ã‚§ã‚¯ãƒˆã‚µãƒ¼ãƒ: ${depth}æ‰‹èª­ã¿ã€‘`);
            } else {
                updateMessage(`AI (ç™½) ã®æ€è€ƒä¸­ã§ã™...ã€ä¸­ç›¤ã‚µãƒ¼ãƒ: ${depth}æ‰‹èª­ã¿ã€‘`);
            }

            let bestMove = null;
            let maxEval = -Infinity;
            let alpha = -Infinity;
            const beta = Infinity;

            for (const move of validMoves) {
                const newBoard = currentBoard.map(row => [...row]);
                makeMove(newBoard, move.row, move.col, WHITE);

                const evaluation = minimax(newBoard, depth - 1, alpha, beta, false);

                if (evaluation > maxEval) {
                    maxEval = evaluation;
                    bestMove = move;
                }
                alpha = Math.max(alpha, maxEval);
            }
            return bestMove;
        }

        // --- æç”»ã¨ã‚²ãƒ¼ãƒ ãƒ•ãƒ­ãƒ¼ ---
        
        function drawBoard() {
            boardContainer.innerHTML = '';
            const validMoves = (!isGameOver && currentPlayer === BLACK) ? getValidMoves(board, BLACK) : [];

            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const cell = document.createElement('div');
                    cell.classList.add('cell');
                    cell.dataset.row = r;
                    cell.dataset.col = c;
                    cell.addEventListener('click', handleCellClick);

                    const isHint = validMoves.some(move => move.row === r && move.col === c);
                    if (isHint) {
                        cell.classList.add('hint');
                    }

                    if (board[r][c] !== EMPTY) {
                        const disc = document.createElement('div');
                        disc.classList.add('disc');
                        if (board[r][c] === BLACK) {
                            disc.classList.add('black');
                        } else if (board[r][c] === WHITE) {
                            disc.classList.add('white');
                        }
                        cell.appendChild(disc);
                    }
                    boardContainer.appendChild(cell);
                }
            }
        }

        function checkGameEnd() {
            const blackMoves = getValidMoves(board, BLACK).length;
            const whiteMoves = getValidMoves(board, WHITE).length;

            if (blackMoves === 0 && whiteMoves === 0) {
                isGameOver = true;
                let blackCount = 0;
                let whiteCount = 0;

                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        if (board[r][c] === BLACK) blackCount++;
                        if (board[r][c] === WHITE) whiteCount++;
                    }
                }

                let result = `ã‚²ãƒ¼ãƒ çµ‚äº†ï¼é»’: ${blackCount}ã€ç™½: ${whiteCount}ã€‚`;
                if (blackCount > whiteCount) {
                    result += "ã‚ãªãŸã®å‹ã¡ã§ã™ï¼ğŸ‰";
                } else if (whiteCount > blackCount) {
                    result += "AIã®å‹ã¡ã§ã™ã€‚ğŸ¤–";
                } else {
                    result += "å¼•ãåˆ†ã‘ã§ã™ã€‚";
                }
                updateMessage(result);
                return true;
            }
            return false;
        }

        function runAI() {
            const validMoves = getValidMoves(board, WHITE);

            if (validMoves.length > 0) {
                const bestMove = findAIBestMove(board);

                makeMove(board, bestMove.row, bestMove.col, WHITE);
                
                if (checkGameEnd()) {
                    drawBoard();
                    return;
                }
                
                currentPlayer = BLACK;
                
                if (getValidMoves(board, BLACK).length > 0) {
                     updateMessage("ã‚ãªãŸã®ç•ªã§ã™ (é»’)");
                     drawBoard(); 
                } else {
                     updateMessage("ã‚ãªãŸã¯ãƒ‘ã‚¹ã§ã™ã€‚AIã®ç•ªãŒç¶šãã¾ã™ã€‚");
                     currentPlayer = WHITE;
                     setTimeout(runAI, 1000); 
                }
            } else {
                updateMessage("AIã¯ãƒ‘ã‚¹ã§ã™ã€‚ã‚ãªãŸã®ç•ªãŒç¶šãã¾ã™ (é»’)");
                currentPlayer = BLACK;
                
                if (getValidMoves(board, BLACK).length === 0) {
                    checkGameEnd();
                }
                
                drawBoard(); 
            }
        }

        function handleCellClick(event) {
            if (isGameOver || currentPlayer !== BLACK) {
                return;
            }

            const row = parseInt(event.currentTarget.dataset.row);
            const col = parseInt(event.currentTarget.dataset.col);

            if (isValidMove(board, row, col, BLACK)) {
                makeMove(board, row, col, BLACK);
                
                if (checkGameEnd()) {
                    drawBoard();
                    return;
                }
                
                currentPlayer = WHITE;
                
                drawBoard(); 

                // çµ‚ç›¤æˆ¦ã®è² è·ã‚’è€ƒæ…®ã—ã€æ€è€ƒæ™‚é–“ã¯é•·ã‚ã«è¨­å®šï¼ˆ1ç§’ï¼‰
                setTimeout(() => {
                    if (isGameOver) return;

                    if (getValidMoves(board, WHITE).length > 0) {
                        runAI();
                    } else {
                        updateMessage("AIã¯ãƒ‘ã‚¹ã§ã™ã€‚ã‚ãªãŸã®ç•ªãŒç¶šãã¾ã™ (é»’)");
                        currentPlayer = BLACK;

                        if (getValidMoves(board, BLACK).length === 0) {
                            checkGameEnd();
                        }
                        drawBoard();
                    }
                }, 1000); 

            } else {
                updateMessage("ãã“ã«ã¯ç½®ã‘ã¾ã›ã‚“ã€‚ç™½ã„ç‚¹ãŒè¡¨ç¤ºã•ã‚Œã¦ã„ã‚‹ãƒã‚¹ã‚’é¸ã‚“ã§ãã ã•ã„ã€‚");
            }
        }

        // --- åˆæœŸåŒ–ã¨ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ ---
        initGame();
        resetButton.addEventListener('click', initGame);
    </script>
</body>
</html>
        /* ç½®ã‘ã‚‹ãƒã‚¹ã«ãƒ’ãƒ³ãƒˆã‚’è¡¨ç¤º */
        .cell.hint::after {
            content: '';
            display: block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.6);
            position: absolute;
        }
    </style>
</head>
<body>
    <h1>AIå¯¾æˆ¦ã‚ªã‚»ãƒ­ (ç©¶æ¥µç‰ˆ)</h1>
    
    <div id="message">ã‚²ãƒ¼ãƒ é–‹å§‹ï¼ã‚ãªãŸã®ç•ªã§ã™ (é»’)</div>

    <div id="board-container"></div>
    
    <button id="reset-button">ã‚²ãƒ¼ãƒ ãƒªã‚»ãƒƒãƒˆ</button>

    <script>
        // --- å®šæ•°ã¨å¤‰æ•° ---
        const EMPTY = 0;
        const BLACK = 1; // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼
        const WHITE = 2; // AI

        // ã€æœ€å¼·ã®æ ¸ 1ã€‘ä½ç½®è©•ä¾¡ãƒ†ãƒ¼ãƒ–ãƒ«
        const POSITION_WEIGHTS = [
            [ 100, -20,  10,  5,  5,  10, -20,  100], 
            [-20, -50,  -2, -2, -2,  -2, -50,  -20], 
            [ 10,  -2,  -1, -1, -1,  -1,  -2,   10],
            [  5,  -2,  -1,  0,  0,  -1,  -2,    5],
            [  5,  -2,  -1,  0,  0,  -1,  -2,    5],
            [ 10,  -2,  -1, -1, -1,  -1,  -2,   10],
            [-20, -50,  -2, -2, -2,  -2, -50,  -20],
            [ 100, -20,  10,  5,  5,  10, -20,  100]
        ];
        
        // ã€æœ€å¼·ã®æ ¸ 2ã€‘æ¢ç´¢ã®æ·±ã•ã¨çµ‚ç›¤åˆ¤å®š
        const MIDGAME_SEARCH_DEPTH = 5; // ä¸­ç›¤æˆ¦ã®æ¢ç´¢æ·±ã•
        const ENDGAME_THRESHOLD = 12; // ç©ºããƒã‚¹ãŒ12ä»¥ä¸‹ã«ãªã£ãŸã‚‰å…¨æ¢ç´¢é–‹å§‹
        const MOBILITY_WEIGHT = 5;      // ãƒ¢ãƒ“ãƒªãƒ†ã‚£è©•ä¾¡ã®é‡ã¿
        
        let board; 
        let currentPlayer;
        let isGameOver = false;
        const boardContainer = document.getElementById('board-container');
        const messageElement = document.getElementById('message');
        const resetButton = document.getElementById('reset-button');

        const DIRECTIONS = [
            [-1, 0], [1, 0], [0, -1], [0, 1], 
            [-1, -1], [-1, 1], [1, -1], [1, 1]
        ];

        // --- åŸºæœ¬é–¢æ•°ï¼ˆå¤‰æ›´ãªã—ï¼‰ ---

        function updateMessage(text) {
            messageElement.textContent = text;
        }

        function initGame() {
            board = [
                [0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, WHITE, BLACK, 0, 0, 0],
                [0, 0, 0, BLACK, WHITE, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0]
            ];
            currentPlayer = BLACK;
            isGameOver = false;
            drawBoard();
            updateMessage("ã‚²ãƒ¼ãƒ é–‹å§‹ï¼ã‚ãªãŸã®ç•ªã§ã™ (é»’)");
        }
        
        function getFlips(currentBoard, r, c, player) {
            if (currentBoard[r][c] !== EMPTY) return []; 
            const opponent = player === BLACK ? WHITE : BLACK;
            let flippedDiscs = [];
            for (const [dr, dc] of DIRECTIONS) {
                let currentFlips = [];
                let nr = r + dr;
                let nc = c + dc;
                while (nr >= 0 && nr < 8 && nc >= 0 && nc < 8 && currentBoard[nr][nc] === opponent) {
                    currentFlips.push({ row: nr, col: nc });
                    nr += dr;
                    nc += dc;
                }
                if (nr >= 0 && nr < 8 && nc >= 0 && nc < 8 && currentBoard[nr][nc] === player) {
                    flippedDiscs.push(...currentFlips);
                }
            }
            return flippedDiscs;
        }

        function isValidMove(currentBoard, r, c, player) {
            return getFlips(currentBoard, r, c, player).length > 0;
        }

        function makeMove(currentBoard, r, c, player) {
            const flips = getFlips(currentBoard, r, c, player);
            currentBoard[r][c] = player;
            for (const { row, col } of flips) {
                currentBoard[row][col] = player;
            }
        }

        function getValidMoves(currentBoard, player) {
            const moves = [];
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (currentBoard[r][c] === EMPTY && isValidMove(currentBoard, r, c, player)) {
                        moves.push({ row: r, col: c });
                    }
                }
            }
            return moves;
        }

        // --- AIãƒ­ã‚¸ãƒƒã‚¯ï¼ˆãƒŸãƒ‹ãƒãƒƒã‚¯ã‚¹/è©•ä¾¡é–¢æ•°ï¼‰ ---
        
        function checkGameOverState(currentBoard) {
            const blackMoves = getValidMoves(currentBoard, BLACK).length;
            const whiteMoves = getValidMoves(currentBoard, WHITE).length;
            return blackMoves === 0 && whiteMoves === 0;
        }

        /**
         * æœ€çµ‚ç›¤ã®çŸ³æ•°è©•ä¾¡é–¢æ•° (ã‚¹ã‚³ã‚¢ã¯WHITEã®çŸ³æ•° - BLACKã®çŸ³æ•°)
         */
        function finalScoreEvaluation(currentBoard) {
            let whiteCount = 0;
            let blackCount = 0;
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (currentBoard[r][c] === WHITE) whiteCount++;
                    if (currentBoard[r][c] === BLACK) blackCount++;
                }
            }
            // è©•ä¾¡å€¤ã®ã‚¹ã‚±ãƒ¼ãƒ«ã‚’åˆã‚ã›ã‚‹ãŸã‚ã«å¤§ããªä¿‚æ•°ã‚’ã‹ã‘ã‚‹
            return (whiteCount - blackCount) * 100000; 
        }

        /**
         * ä¸­ç›¤æˆ¦ã®è©•ä¾¡é–¢æ•°ï¼ˆä½ç½® + ãƒ¢ãƒ“ãƒªãƒ†ã‚£ï¼‰
         */
        function midgameEvaluation(currentBoard) {
            let whiteScore = 0;
            let blackScore = 0;

            // 1. ä½ç½®è©•ä¾¡ (Placement Score)
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const weight = POSITION_WEIGHTS[r][c];
                    if (currentBoard[r][c] === WHITE) {
                        whiteScore += weight;
                    } else if (currentBoard[r][c] === BLACK) {
                        blackScore += weight;
                    }
                }
            }

            // 2. ãƒ¢ãƒ“ãƒªãƒ†ã‚£è©•ä¾¡ (Mobility Score)
            const whiteMobility = getValidMoves(currentBoard, WHITE).length;
            const blackMobility = getValidMoves(currentBoard, BLACK).length;
            const mobilityScore = MOBILITY_WEIGHT * (whiteMobility - blackMobility);

            // æœ€çµ‚ã‚¹ã‚³ã‚¢: (ä½ç½®è©•ä¾¡ã®å·®) + (ãƒ¢ãƒ“ãƒªãƒ†ã‚£è©•ä¾¡)
            return (whiteScore - blackScore) + mobilityScore;
        }
        
        /**
         * ç©ºããƒã‚¹æ•°ã‚’æ•°ãˆã‚‹
         */
        function countEmptyCells(currentBoard) {
            let emptyCount = 0;
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (currentBoard[r][c] === EMPTY) emptyCount++;
                }
            }
            return emptyCount;
        }


        // ã‚¢ãƒ«ãƒ•ã‚¡ãƒ™ãƒ¼ã‚¿æåˆˆã‚Šä»˜ããƒŸãƒ‹ãƒãƒƒã‚¯ã‚¹æ³•
        function minimax(currentBoard, depth, alpha, beta, isMaximizingPlayer) {
            const emptyCells = countEmptyCells(currentBoard);
            const isEndgame = emptyCells <= ENDGAME_THRESHOLD;

            // æ¢ç´¢çµ‚äº†æ¡ä»¶
            if (depth === 0 || checkGameOverState(currentBoard) || isEndgame) {
                // çµ‚ç›¤ã«çªå…¥ã—ãŸã‚‰ã€æœ€çµ‚çš„ãªçŸ³æ•°ã§è©•ä¾¡
                if (checkGameOverState(currentBoard) || isEndgame) {
                     return finalScoreEvaluation(currentBoard);
                }
                // ä¸­ç›¤ã®æ¢ç´¢æ·±ã•é™ç•Œã«é”ã—ãŸã‚‰ã€ä¸­ç›¤è©•ä¾¡é–¢æ•°ã§è©•ä¾¡
                return midgameEvaluation(currentBoard);
            }

            const player = isMaximizingPlayer ? WHITE : BLACK;
            const validMoves = getValidMoves(currentBoard, player);
            
            // ãƒ‘ã‚¹ã®å‡¦ç†
            if (validMoves.length === 0) {
                return minimax(currentBoard, depth - 1, alpha, beta, !isMaximizingPlayer);
            }

            if (isMaximizingPlayer) {
                let maxEval = -Infinity;
                for (const move of validMoves) {
                    const newBoard = currentBoard.map(row => [...row]); 
                    makeMove(newBoard, move.row, move.col, player);
                    const evaluation = minimax(newBoard, depth - 1, alpha, beta, false);
                    maxEval = Math.max(maxEval, evaluation);
                    alpha = Math.max(alpha, maxEval);
                    if (beta <= alpha) break; 
                }
                return maxEval;
            } else {
                let minEval = Infinity;
                for (const move of validMoves) {
                    const newBoard = currentBoard.map(row => [...row]);
                    makeMove(newBoard, move.row, move.col, player);
                    const evaluation = minimax(newBoard, depth - 1, alpha, beta, true);
                    minEval = Math.min(minEval, evaluation);
                    beta = Math.min(beta, minEval);
                    if (beta <= alpha) break; 
                }
                return minEval;
            }
        }

        // AIã®æœ€å–„æ‰‹ã‚’æ±ºå®šã™ã‚‹ãƒ¡ã‚¤ãƒ³é–¢æ•°
        function findAIBestMove(currentBoard) {
            const validMoves = getValidMoves(currentBoard, WHITE);
            if (validMoves.length === 0) return null;

            const emptyCells = countEmptyCells(currentBoard);
            
            // çµ‚ç›¤æˆ¦ã®åˆ¤å®š
            const isEndgame = emptyCells <= ENDGAME_THRESHOLD;
            const depth = isEndgame ? emptyCells : MIDGAME_SEARCH_DEPTH; // çµ‚ç›¤ãªã‚‰æ®‹ã‚Šç©ºããƒã‚¹æ•°ã‚’æ·±åº¦ã¨ã™ã‚‹

            if(isEndgame) {
                updateMessage(`AI (ç™½) ã®æ€è€ƒä¸­ã§ã™...ã€çµ‚ç›¤ãƒ‘ãƒ¼ãƒ•ã‚§ã‚¯ãƒˆã‚µãƒ¼ãƒ: ${depth}æ‰‹èª­ã¿ã€‘`);
            } else {
                updateMessage(`AI (ç™½) ã®æ€è€ƒä¸­ã§ã™...ã€ä¸­ç›¤ã‚µãƒ¼ãƒ: ${depth}æ‰‹èª­ã¿ã€‘`);
            }

            let bestMove = null;
            let maxEval = -Infinity;
            let alpha = -Infinity;
            const beta = Infinity;

            for (const move of validMoves) {
                const newBoard = currentBoard.map(row => [...row]);
                makeMove(newBoard, move.row, move.col, WHITE);

                // ç›¸æ‰‹ã®ã‚¿ãƒ¼ãƒ³ï¼ˆæœ€å°åŒ–ï¼‰ã¨ã—ã¦ãƒŸãƒ‹ãƒãƒƒã‚¯ã‚¹ã‚’é–‹å§‹
                const evaluation = minimax(newBoard, depth - 1, alpha, beta, false);

                if (evaluation > maxEval) {
                    maxEval = evaluation;
                    bestMove = move;
                }
                alpha = Math.max(alpha, maxEval);
            }
            return bestMove;
        }

        // --- æç”»ã¨ã‚²ãƒ¼ãƒ ãƒ•ãƒ­ãƒ¼ ---
        
        function drawBoard() {
            boardContainer.innerHTML = '';
            const validMoves = (!isGameOver && currentPlayer === BLACK) ? getValidMoves(board, BLACK) : [];

            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const cell = document.createElement('div');
                    cell.classList.add('cell');
                    cell.dataset.row = r;
                    cell.dataset.col = c;
                    cell.addEventListener('click', handleCellClick);
                    const isHint = validMoves.some(move => move.row === r && move.col === c);
                    if (isHint) {
                        cell.classList.add('hint');
                    }
                    if (board[r][c] !== EMPTY) {
                        const disc = document.createElement('div');
                        disc.classList.add('disc');
                        if (board[r][c] === BLACK) {
                            disc.classList.add('black');
                        } else if (board[r][c] === WHITE) {
                            disc.classList.add('white');
                        }
                        cell.appendChild(disc);
                    }
                    boardContainer.appendChild(cell);
                }
            }
        }

        function checkGameEnd() {
            const blackMoves = getValidMoves(board, BLACK).length;
            const whiteMoves = getValidMoves(board, WHITE).length;

            if (blackMoves === 0 && whiteMoves === 0) {
                isGameOver = true;
                let blackCount = 0;
                let whiteCount = 0;

                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        if (board[r][c] === BLACK) blackCount++;
                        if (board[r][c] === WHITE) whiteCount++;
                    }
                }

                let result = `ã‚²ãƒ¼ãƒ çµ‚äº†ï¼é»’: ${blackCount}ã€ç™½: ${whiteCount}ã€‚`;
                if (blackCount > whiteCount) {
                    result += "ã‚ãªãŸã®å‹ã¡ã§ã™ï¼ğŸ‰";
                } else if (whiteCount > blackCount) {
                    result += "AIã®å‹ã¡ã§ã™ã€‚ğŸ¤–";
                } else {
                    result += "å¼•ãåˆ†ã‘ã§ã™ã€‚";
                }
                updateMessage(result);
                return true;
            }
            return false;
        }

        function runAI() {
            const validMoves = getValidMoves(board, WHITE);

            if (validMoves.length > 0) {
                const bestMove = findAIBestMove(board); // æ·±åº¦ã¯ findAIBestMove å†…ã§æ±ºå®š

                makeMove(board, bestMove.row, bestMove.col, WHITE);
                
                if (checkGameEnd()) {
                    drawBoard();
                    return;
                }
                
                currentPlayer = BLACK;
                
                if (getValidMoves(board, BLACK).length > 0) {
                     updateMessage("ã‚ãªãŸã®ç•ªã§ã™ (é»’)");
                     drawBoard(); 
                } else {
                     updateMessage("ã‚ãªãŸã¯ãƒ‘ã‚¹ã§ã™ã€‚AIã®ç•ªãŒç¶šãã¾ã™ã€‚");
                     currentPlayer = WHITE;
                     setTimeout(runAI, 1000); 
                }
            } else {
                updateMessage("AIã¯ãƒ‘ã‚¹ã§ã™ã€‚ã‚ãªãŸã®ç•ªãŒç¶šãã¾ã™ (é»’)");
                currentPlayer = BLACK;
                
                if (getValidMoves(board, BLACK).length === 0) {
                    checkGameEnd();
                }
                
                drawBoard(); 
            }
        }

        function handleCellClick(event) {
            if (isGameOver || currentPlayer !== BLACK) {
                return;
            }

            const row = parseInt(event.currentTarget.dataset.row);
            const col = parseInt(event.currentTarget.dataset.col);

            if (isValidMove(board, row, col, BLACK)) {
                makeMove(board, row, col, BLACK);
                
                if (checkGameEnd()) {
                    drawBoard();
                    return;
                }
                
                currentPlayer = WHITE;
                
                drawBoard(); 

                // AIã®æ€è€ƒæ™‚é–“ã¯ã€çµ‚ç›¤ã®ãƒ‘ãƒ¼ãƒ•ã‚§ã‚¯ãƒˆã‚µãƒ¼ãƒã®è² è·ã‚’è€ƒæ…®ã—ã¦é•·ã‚ã«è¨­å®šï¼ˆ1ç§’ï¼‰
                setTimeout(() => {
                    if (isGameOver) return;

                    if (getValidMoves(board, WHITE).length > 0) {
                        runAI();
                    } else {
                        updateMessage("AIã¯ãƒ‘ã‚¹ã§ã™ã€‚ã‚ãªãŸã®ç•ªãŒç¶šãã¾ã™ (é»’)");
                        currentPlayer = BLACK;

                        if (getValidMoves(board, BLACK).length === 0) {
                            checkGameEnd();
                        }
                        drawBoard();
                    }
                }, 1000); 

            } else {
                updateMessage("ãã“ã«ã¯ç½®ã‘ã¾ã›ã‚“ã€‚ç™½ã„ç‚¹ãŒè¡¨ç¤ºã•ã‚Œã¦ã„ã‚‹ãƒã‚¹ã‚’é¸ã‚“ã§ãã ã•ã„ã€‚");
            }
        }

        // --- åˆæœŸåŒ–ã¨ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ ---
        initGame();
        resetButton.addEventListener('click', initGame);
    </script>
</body>
</html>
